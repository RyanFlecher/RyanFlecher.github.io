<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS-关于自动化构建的方案]]></title>
    <url>%2F2018%2F08%2F22%2FiOS-%E5%85%B3%E4%BA%8E%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E7%9A%84%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[实施目的：优化开发-测试-发布流程当前情况：iOS端开发后手动Build给QA，期间QA提出bug，开发修复后再次进行手动Biuld， 且发布后，无法保证发布版本与测试版本的同步性。故提出此方案，旨在优化流程。 第一阶段优化期望：iOS自动Build至蒲公英内测平台，同时生成生产环境IPA至TestFlight，二者构建版本号相同。经QA同学在蒲公英平台下载验证测试环境通过后，通过TestFlight App验证正式环境，通过后直接由运营同学上线。 第二阶段优化期望：测试IPA，正式IPA统一由云端管理。验证后，由fastlane发布至App Store Connect。 为什么是两个阶段？ 目前开发，QA人员、精（zhi）力（you）均（wo）有（zi）限（ji）。 蒲公英平台为付费专业版，理论上没有流量限制，功能丰富（密码提取、微信通知、浏览器下载安装不需要使用ITunes同步），运营同学可以在App Store Connect直接提取QA验证过的IPA进行操作，既节省了额外学习Application loader时间，也避免了微信、钉钉等传输工具所带来的风险。（转发出错，IPA被破解、注入） 选型思路在调研了一些自动化工具后，选择了fastlane + jenkins， 二者均可以单独使用，也可以搭配使用。 fastlane优点在于轻量化且配置容易，上手快，它提供了许多好用的工具，还有直观的脚本，让你可以不用碰触到很多系統的细节面，也能够做到各种客制流程，而且它同時支援 iOS/ MacOS 和 Android 平台。大多数的设定你都可以透过commandline 直接跟 xcode 互动做到。 jenkins是一個有网页 UI 的自动化工具，让你可以利用 GUI 设定工作內容，像是设定 project 参数等，也可以做到执行排程，像是每日定時任务等。功能强大，支持git，以及历史版本的保存（协同云端）。QA可以自由在分支间，版本间进行切换。 解决思路使用fastlane作为过渡工具，建立起新的标准流程，待后期条件成熟，将jenkins加入。二者的组合可以最大限度发挥fastlane的构建速度与jenkins版本控制的优点。 为什么不直接是jenkins？ 在日常的使用中，jenkins凭借其插件的庞大数量和丰富的功能让人心旷神怡，但也正因如此，在和xcode的配合中，由于每个插件的维护和更新时间无法控制，因此会造成版本过渡期的失效。问题出现场景：适配xcode 10 SDK，更新后插件扔停留在xcode 9，此时自动化功能受损。抛开插件，jenkins不具备直接上传的能力，这就意味着不论是正式IPA、测试IPA，都将直接暴露于各个非专业传输工具中，相关工作人员的桌面、废纸篓中。风险不言而喻。 为发挥jenkins的最大效能，云端功能和本地的一些参数需要时间配置并进行测试。 第一阶段相关技术细节xcode方面在编译器中，首先通过Preprocessing + Configuration加入新的环境及配置项，将API、包名（易港金融、易港金融Beta）区分开。 fastlane方面为了节省阅读者时间，关于fastlane的安装和配置文中不在赘述。 当在控制台执行测试工作流时，会自动生成一个生产环境的IPA提交至App Store。 Connect。 注：截止本稿发出，第一阶段已准备完毕。 第二阶段相关技术细节为了节省读者时间，关于jenkins的安装和配置文中不在赘述。 构建触发器，这里我们选择Poll SCM，然后在下方输入框填入日程描述H/10 * * * *，表示每10分钟从仓库拉取一次，如果有新的提交，那么构建项目。 写入shell文件，此处填入在之前控制台执行的fastlane命令。 更深层次的功能会在使用测试后逐渐完善。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EarlGrey-API的翻译]]></title>
    <url>%2F2018%2F05%2F22%2FEarlGrey-API%E7%9A%84%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[APIEarlGrey包含三组主要的API： 交互API 同步API 其他API 交互APIEarlGrey的测试用例由一系列的UI元素交互组成。 每个交互包括： 选择一个元素进行交互 对其执行操作，与(&amp;&amp;) /或(||) 做出断言来验证元素的状态和行为 为了体现上述行为，交互API由以下内容组成： 选中元素相关API 操作相关API 断言相关API 这些API中的每一个接口都考虑到了可扩展性，让用户可以进行灵活的定制，同时保留了测试代码的可读性。阅读下面的代码片段： 1[EarlGrey selectElementWithMatcher:grey_accessibilityID(@&quot;ClickMe&quot;)]; 它显示了如何通过Accessibility Identifier为ClickMe的元素来启动交互。选择元素后，你可以以操作该元素或者断言的方式继续交互。 EarlGrey可以使用任何符合UIAccessibility protocol的元素，而不仅仅是UIViews，这就让测试用例可以执行更丰富的交互。 你可以将元素选择和操作在一行代码中完成。例如，点击一个Accessibility Identity为ClickMe的元素可以这样写： 12[[EarlGrey selectElementWithMatcher:grey_accessibilityID(@&quot;ClickMe&quot;)] performAction:grey_tap()]; 注意：selectElementWithMatcher:不返回一个元素， 它只是标志着互动的开始。 你可以将元素选择和断言在一行代码中完成。下面的代码将展示选择一个Accessibility Identity为ClickMe的元素并判断它是否显示： 12[[EarlGrey selectElementWithMatcher:grey_accessibilityID(@&quot;ClickMe&quot;)] assertWithMatcher:grey_sufficientlyVisible()]; 最后，你可以按顺序执行操作和断言。 下面的代码展示了查找Accessibility Identity为ClickMe的元素，点击它并判断其是否显示。 123[[[EarlGrey selectElementWithMatcher:grey_accessibilityID(@&quot;ClickMe&quot;)] performAction:grey_tap()] assertWithMatcher:grey_notVisible()]; 以下是一个简单的交互模板： 123[[[EarlGrey selectElementWithMatcher:&lt;element_matcher&gt;] performAction:&lt;action&gt;] assertWithMatcher:&lt;assertion_matcher&gt;]; 其中&lt;element_matcher&gt;和&lt;assertion_matcher&gt;是包含在GREYMatchers.h中的匹配器，&lt;action&gt;为GREYAction.h中的操作方法。因为每个匹配器或操作都有一个简写的方法，所以可以使用grey_sufficientlyVisible（），来替代[GREYMatchers matcherForSufficientlyVisible]。用简写方法的方式默认是允许的。 要禁用它，请将#define GREY_DISABLE_SHORTHAND 1添加到项目的头文件。 选中元素API使用Selection API来定位屏幕中的UI元素。当API接收到Matcher后会在所有UI分层中定位对应的元素来发生交互。在EarlGrey中，matchers支持一种类似于OCHamcrest matchers的API。你可以使用与或逻辑组合matchers，允许你创建匹配规则，以确定UI分层中的任何元素。 EarlGrey Matchers所有EarlGrey Matchers都可以在GREYMatchers工厂类中找到。 查找UI元素的最佳方法是使用它的accessibility properties。我们强烈建议使用accessibility identifier，因为它是一个元素的唯一标识。 使用grey_accessibilityID（）作为matcher，通过其accessibility traits来定位UI元素。或者使用grey_accessibilityLabel（）作为 accessibility labels的匹配器。 Matcher可能会匹配多个元素：例如，grey_sufficientlyVisible（）将匹配所有可见的UI元素。 在这种情况下，你必须缩小选择范围，直到它可以唯一标识一个UI元素。 你可以通过将matchers与grey_allOf（），grey_anyOf（），grey_not（）结合使用或通过向root matchers提供inRoot方法来缩小选择范围，从而使matchers更加准确。 来看下面的例子。 第一个，使用组合的matchers，以下这段代码将查找accessibility label为Send的元素并且显示在当前屏幕。 12345id&lt;GREYMatcher&gt; visibleSendButtonMatcher = grey_allOf(grey_accessibilityLabel(@&quot;Send&quot;), grey_sufficientlyVisible(), nil);[[EarlGrey selectElementWithMatcher:visibleSendButtonMatcher] performAction:grey_tap()]; 请注意，使用grey_allOf命令很重要。 如果先使用grey_sufficientlyVisible，则将检查整个应用程序中的每个元素的可见性。 从大多数选项中（比如accessibility label和accessibility id）中选择matchers至关重要。 接下来，使用inRoot，以下这段代码将查找accessibility label为Send且被包含在SendMessageView类实例化对象中的UI元素。 123[[[EarlGrey selectElementWithMatcher:grey_accessibilityLabel(@&quot;Send&quot;)] inRoot:grey_kindOfClass([SendMessageView class])] performAction:grey_tap()]; 注意：为了与Swift兼容，我们分别使用grey_allOfMatchers（）和grey_anyOfMatchers（）来代替grey_allOf（）和grey_anyOf（）。 自定义 Matchers要创建自定义matchers，请使用基于block的GREYElementMatcherBlock类。 例如，以下代码用来与没有子视图的视图匹配。 1234567891011+ (id&lt;GREYMatcher&gt;)matcherForViewsWithoutSubviews &#123; MatchesBlock matches = ^BOOL(UIView *view) &#123; return view.subviews.count == 0; &#125;; DescribeToBlock describe = ^void(id&lt;GREYDescription&gt; description) &#123; [description appendText:@&quot;Views without subviews&quot;]; &#125;; return [[GREYElementMatcherBlock alloc] initWithMatchesBlock:matches descriptionBlock:describe];&#125; MatchesBlock除了接受UIView *之外，也可以接受id类型。当matcher用于选取元素时，需要使用id类型。以下matcher示例通用于所有UI元素类型： 1234567891011121314+ (id&lt;GREYMatcher&gt;)matcherForElementWithoutChildren &#123; MatchesBlock matches = ^BOOL(id element) &#123; if ([element isKindOfClass:[UIView class]]) &#123; return ((UIView *)element).subviews.count == 0; &#125; // Handle accessibility elements here. return ...; &#125;; DescribeToBlock describe = ^void(id&lt;GREYDescription&gt; description) &#123; [description appendText:@&quot;UI element without children&quot;]; &#125;; return [[GREYElementMatcherBlock alloc] initWithMatchesBlock:matches descriptionBlock:describe];&#125; 这个matcher可以在测试中用于选取没有任何子元素（或子视图）的元素并且双击它（假设该方法是在CustomMatchers类中声明的）： 12[[EarlGrey selectElementWithMatcher:[CustomMatchers matcherForElementWithoutChildren]] performAction:grey_doubleTap()]; 选取未显示的UI元素在某些情况下，UI元素可能被隐藏或在屏幕外，需要某些交互才能将其展示在屏幕上。 常见示例包括滚动视图中元素未被滚动至可见，放大地图至街景模式可见的UI元素，浏览自定义布局的UICollectionView等。 例如，以下代码通过aButtonMarcher匹配一个元素，此元素在aScrollViewMatcher匹配的滚动视图中，经过重复向下滚动（每次减少50points）找到该元素并点击 1234[[[EarlGrey selectElementWithMatcher:aButtonMatcher] usingSearchAction:grey_scrollInDirection(kGREYDirectionDown, 50) onElementWithMatcher:aScrollViewMatcher] performAction:grey_tap()]; 以下代码用来定位一个UITableView视图中的指定Cell，aTableViewMatcher匹配了该表格视图，通过重复向下滚动（每次减少50points）找到aCellMatcher定位的指定Cell。 1234[[[EarlGrey selectElementWithMatcher:aCellMatcher] usingSearchAction:grey_scrollInDirection(kGREYDirectionUp, 50) onElementWithMatcher:aTableViewMatcher] performAction:grey_tap()]; 操作API使用Action API来描述在选定UI元素上的测试操作。 EarlGrey Actions所有EarlGrey actions都在GREYActions工厂类中。 最常见的操作是使用grey_tap（）方法点击指定元素： 12[[EarlGrey selectElementWithMatcher:grey_accessibilityID(@&quot;TapMe&quot;)] performAction:grey_tap()]; 如果某个操作触发UI层次结构中的更改，则EarlGrey会将每个操作（包括链式操作）与UI同步，以确保在执行下一个操作之前它处于稳定状态。 并非所有操作都可以在所有元素上执行，例如，无法对不可见的元素执行点按操作。为了确保操作可执行，每次执行之前要确保GREYMatcher定位到该元素。未满足这些条件会导致抛出异常并将测试标记为失败。 为了避免测试失败，可以调用performAction：error：获取包含错误详情的NSError对象。 1234NSError *error;[[EarlGrey selectElementWithMatcher:grey_accessibilityID(@&quot;Non-Existent-Ax-Id&quot;)] performAction:grey_tap() error:&amp;error]; 在上面的例子中，在不存在的元素上执行EarlGrey交互时不会抛出异常。 相反，传递的错误对象将保存故障详细信息，并且不会立即使测试失败。 然后可以查看错误详细信息以查找故障详细信息。 自定义操作自定义操作可以通过遵循GREYAction协议的方式来创建。为了方便起见，你可以使用已遵循GREYAction协议的GREYActionBlock，并允许你以block的形式自定义操作。 以下代码用block自定义一个操作（animateWindow）用来设置选中window的动画： 1234567891011121314151617- (id&lt;GREYAction&gt;)animateWindowAction &#123; return [GREYActionBlock actionWithName:@&quot;Animate Window&quot; constraints:nil performBlock:^(id element, NSError *__strong *errorOrNil) &#123; // First, make sure the element is attached to a window. if ([element window] == nil) &#123; // Populate error. *errorOrNil = ... // Indicates that the action failed. return NO; &#125; // Invoke a custom selector that animates the window of the element. [element animateWindow]; // Indicates that the action was executed successfully. return YES; &#125;];&#125; 断言API使用断言API来验证UI元素的状态和行为。 使用Matchers断言使用assertWithMatcher：用GREYMatcher执行断言。 所选元素将通过matcher判断其状态。例如，以下代码判断accessibility ID为ClickMe的元素是否可见，如果元素在屏幕上不可见，则测试失败。 12[[EarlGrey selectElementWithMatcher:grey_accessibilityID(@&quot;ClickMe&quot;)] assertWithMatcher:grey_sufficientlyVisible()]; 为了防止测试失败，可以为assertWithMatcher：error：方法提供一个NSError对象，如下面的代码所示。 相比直接测试失败，它将为你提供一个NSError对象，其中包含有关失败的详细信息。 1234NSError *error;[[EarlGrey selectElementWithMatcher:grey_accessibilityID(@&quot;ClickMe&quot;)] assertWithMatcher:grey_sufficientlyVisible() error:&amp;error]; 你也可以使用assert方法传递一个GREYAssertion实例来执行断言。我们建议你尽可能使用assertWithMatcher：创建断言。Matchers是轻量级的，并且适用于简单的断言。 然而，对于需要执行复杂逻辑的断言（如操作UI）再继续断言，自定义GREYAssertion可能是更好的选择。 自定义断言你可以使用GREYAssertion协议或GREYAssertionBlock来创建自定义断言。以下代码使用GREYAssertionBlock编写断言来检查视图的alpha值是否等于预期的值： 1234567891011121314151617+ (id&lt;GREYAssertion&gt;)hasAlpha:(CGFloat)alpha &#123; return [GREYAssertionBlock assertionWithName:@&quot;Has Alpha&quot; assertionBlock:^(UIView *view, NSError *__strong *errorOrNil) &#123; if (view.alpha != alpha) &#123; NSString *reason = [NSString stringWithFormat:@&quot;Alpha value doesn&apos;t match for %@&quot;, view]; // Check if errorOrNil was provided, if so populate it with relevant details. if (errorOrNil) &#123; *errorOrNil = ... &#125; // Indicates assertion failed. return NO; &#125; // Indicates assertion passed. return YES; &#125;];&#125; 注意：不要认为断言是针对有效的UI元素运行的。 在验证断言之前，你需要自己检查UI元素以确保UI元素处于有效状态。 例如，下面的代码就是在执行断言之前判断元素是否存在： 12345678910111213141516171819+ (id&lt;GREYAssertion&gt;)hasAlpha:(CGFloat)alpha &#123; return [GREYAssertionBlock assertionWithName:@&quot;Has Alpha&quot; assertionBlock:^(UIView *view, NSError *__strong *errorOrNil) &#123; // Assertions can be performed on nil elements. Make sure view isn’t nil. if (view == nil) &#123; // Check if errorOrNil was provided, if so populate it with relevant details. if (errorOrNil) &#123; *errorOrNil = [NSError errorWithDomain:kGREYInteractionErrorDomain code:kGREYInteractionElementNotFoundErrorCode userInfo:nil]; &#125; return NO; &#125; // Perform rest of the assertion logic. ... // Indicates assertion passed. return YES; &#125;];&#125; 或者，你可以创建一个和GREYAssertion类相符的类。 错误处理器默认情况下，在发生异常时，EarlGrey会使用错误处理器。 默认处理器会记录异常，截取屏幕截图，然后打印其路径以及其他有用的信息。你可以选择自定义错误处理器并替换掉全局默认的错误处理器，并使用EarlGrey setFailureHandler：安装在API上。 要创建自定义错误处理器，请编写一个遵循GREYFailureHandler协议的类： 12345678910111213141516@interface@interface MyFailureHandler : NSObject &lt;GREYFailureHandler&gt;@end@implementation MyFailureHandler- (void)handleException:(GREYFrameworkException *)exception details:(NSString *)details &#123; // Log the failure and state of the app if required. // Call thru to XCTFail() with an appropriate error message.&#125;- (void)setInvocationFile:(NSString *)fileName andInvocationLine:(NSUInteger)lineNumber &#123; // Record the file name and line number of the statement which was executing before the // failure occurred.&#125;@end 断言宏EarlGrey提供了自带的宏，可以在测试用例中用于断言和验证。 这些宏与XCTest提供的宏相似，档断言失败时调用全局的错误处理器。 GREYAssert(expression, reason, ...) — 如果表达式输出结果为false，则失败 GREYAssertTrue(expression, reason, ...) — 如果表达式输出结果为false，则失败。用于BOOL表达式 GREYAssertFalse(expression, reason, ...) — 如果表达式输出结果为true，则失败。用于BOOL表达式 GREYAssertNotNil(expression, reason, ...) — 如果表达式输出结果为nil，则失败。 GREYAssertNil(expression, reason, ...) — 如果表达式输出结果非nil，则失败。 GREYAssertEqual(left, right, reason, ...) — 如果 left != right时失败 GREYAssertNotEqual(left, right, reason, ...) — 如果 left == right时失败 GREYAssertEqualObjects(left, right, reason, ...) — 如果 [left isEqual:right]返回false时失败 GREYAssertNotEqualObjects(left, right, reason, ...) — 如果 [left isEqual:right]返回true时失败 GREYFail(reason, ...) — 失败后提供失败的原因 GREYFailWithDetails(reason, details, ...) — 失败后提供失败的原因和细节 布局测试EarlGrey提供API来验证UI元素的布局，例如验证元素X位于元素Y的左侧。布局断言是根据NSLayoutConstraint构建的。要验证布局，需要先创建一个约束来描述布局，选择一个约束它的元素，然后使用grey_layout（…）声明它与约束匹配。 请注意，grey_layout（…）接受的所有约束都必须满足。 这可以简单地描述复杂的布局断言。 例如，以下代码就是指定元素位于所有其他元素右边。 123456GREYLayoutConstraint *rightConstraint = [GREYLayoutConstraint layoutConstraintWithAttribute:kGREYLayoutAttributeLeft relatedBy:kGREYLayoutRelationGreaterThanOrEqual toReferenceAttribute:kGREYLayoutAttributeRight multiplier:1.0 constant:0.0]; 你现在可以选择accessibility ID为RelativeRight的元素，并使用grey_layout（@ [rightConstraint]）来断言它是否位于accessibility ID为TheReference元素的右侧。 12[[EarlGrey selectElementWithMatcher:grey_accessibilityID(@”RelativeRight”)] assertWithMatcher:grey_layout(@[rightConstraint], grey_accessibilityID(@”TheReference”))]; 你还可以使用layoutConstraintForDirection：创建简单的定向约束。 以下代码效果等同于前面的示例： 123GREYLayoutConstraint *rightConstraint = [GREYLayoutConstraint layoutConstraintForDirection:kGREYLayoutDirectionRight andMinimumSeparation:0.0]; 同步API这些API可让你控制EarlGrey与待测应用程序同步。 GREYCondition如果你的测试用例需要特殊处理，你可以使用GREYCondition等待或同步某些条件。 GREYCondition采用返回BOOL的block来表示是否满足条件。 在继续测试剩余部分之前，框架会轮询该block直到满足条件。 以下代码说明如何创建和使用GREYCondition： 12345678910GREYCondition *myCondition = [GREYCondition conditionWithName:@&quot;my condition&quot; block:^BOOL &#123; ... do your condition check here ... return yesIfMyConditionWasSatisfied;&#125;];// Wait for my condition to be satisfied or timeout after 5 seconds.BOOL success = [myCondition waitWithTimeout:5];if (!success) &#123; // Handle condition timeout.&#125; 同步性EarlGrey通过跟踪主要调度队列，主操作队列，网络，UI绘制和其他几个信号自动等待应用程序闲置，并仅在应用程序处于空闲状态时才执行交互。 但是，尽管有时应用程序处于忙碌状态，但仍可能会出现有些交互必须执行的情况。 例如，在消息类的应用程序中，照片可能正在上传并且相应UI绘制正在运行，此时仍然需要测试输入并发送文字信息。在这种情况下，可以使用kGREYConfigKeySynchronizationEnabled禁用EarlGrey的同步，如以下代码所示： 12[[GREYConfiguration sharedInstance] setValue:@(NO) forConfigKey:kGREYConfigKeySynchronizationEnabled]; 一旦禁用，所有的交互都将继续进行，无需等待应用程序闲置，直到重新启用同步。 请注意，为了最大限度地提高测试效率，必须尽快重新启用同步。 而不是完全禁用同步，你可以配置同步参数以适应你的应用程序的需求。 例如： kGREYConfigKeyNSTimerMaxTrackableInterval 用来设定非重复NSTimers的最大间隔。 kGREYConfigKeyDispatchAfterMaxTrackableDelay 通过 dispatch_after调用设定下一步操作的最大延迟时间。 kGREYConfigKeyURLBlacklistRegex 用来设定不需要同步的URL黑名单的正则表达式 在GREYConfiguration中有几种类似的配置。 详细请参阅下面的一些特定用例。 网络默认情况下，EarlGrey会与所有网络请求同步，但你可以通过正则表达式来自定义无需同步的请求。如果要将一个URL列入黑名单中，请创建一个与其匹配的正则表达式，将其添加到NSArray并将其传递给GREYConfiguration。 对于多个网址，请通过为每个网址创建一个正则表达式来重复上述的过程。例如，要告诉框架不要同步www.google.com和www.youtube.com，请执行以下操作： 123NSArray *blacklist = @[ @&quot;.*www\\.google\\.com&quot;, @&quot;.*www\\.youtube\\.com&quot; ];[[GREYConfiguration sharedInstance] setValue:blacklist forConfigKey:kGREYConfigKeyURLBlacklistRegex]; 交互超时无限重复的页面绘制或长时间运行的动画会影响同步。 绘制时间超过测试时间最大值的动画会导致超时异常。 为了避免这种情况，EarlGrey将绘制持续时间限制为5秒，并禁用重复绘制（连续绘制只运行一次）。要操作EarlGrey允许绘制运行更长时间，请更改允许的最大绘制持续时间值。 确保这不会导致你的测试超时。 以下代码将最大绘制持续时间增加到30秒。 12[[GREYConfiguration sharedInstance] setValue:@(30.0) forConfigKey:kGREYConfigKeyCALayerMaxAnimationDuration]; 非主线程调用由于分发队列的限制和EarlGrey与它们同步的方式，从dispatch_queue调用EarlGrey语句会导致活锁。 为了减少这种情况，我们引入了新的基于block的API来封装EarlGrey语句，并且可以从非主线程安全地调用它们： grey_execute_sync(void (^block)()) — 同步。 阻塞直到执行完成。 grey_execute_async(void (^block)()) — 异步。 其他APIUI交互之外，你可以操作EarlGrey以多种方式控制设备和系统。 全局配置GREYConfiguration类允许你配置框架。 它提供了配置同步，交互超时，操作约束checks，日志记录等方法。只要配置发生更改，它就会全局应用。 例如，以下代码将启用详细日志： 12[[GREYConfiguration sharedInstance] setValue:@(YES) forConfigKey:kGREYConfigKeyVerboseLogging]; 控制设备的朝向要旋转设备，请使用[EarlGrey rotateDeviceToOrientation：errorOrNil：]以指定设备朝向。例如，以下代码会操作你的系统（和你的应用）从竖屏变为横屏并且Home键位于右侧： 1[EarlGrey rotateDeviceToOrientation:UIDeviceOrientationLandscapeLeft errorOrNil:nil]; 你可以从以下模式中进行选择（有关更多信息，请参阅UIDeviceOrientation）： UIDeviceOrientationUnknown UIDeviceOrientationPortrait UIDeviceOrientationPortraitUpsideDown UIDeviceOrientationLandscapeLeft UIDeviceOrientationLandscapeRight UIDeviceOrientationFaceUp UIDeviceOrientationFaceDown 摇一摇操作你可以使用[EarlGrey shakeDeviceWithError：]模拟模拟器中的摇一摇操作。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EarlGrey-install and run的翻译]]></title>
    <url>%2F2018%2F05%2F17%2FEarlGrey-install%20and%20run%E7%9A%84%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[安装和运行本文档向你介绍如何安装配置EarlGrey并完成你的第一次测试。 安装EarlGrey你可以通过三种方式将EarlGrey添加到Xcode项目中：使用CocoaPods，Carthage或通过XCode Pjoject手动集成。 对于EarlGrey，我们强烈推荐CocoaPods作为安装的最佳方式，以保持EarlGrey版本是最新的。 CocoaPods安装第1步：设置单元测试目标 要创建一个新的单元测试（XCTest）目标，请在Xcode Project Navigator中选择你的项目，然后从菜单中单击Editor → Add Target… 在添加目标窗口中，选择 iOS → Test → iOS Unit Testing Bundle：点击Next →Add a Test Target Name→Finish. Test Target必须有与之相关的Scheme。要添加一个Scheme，请转到Product → Scheme → Manage Schemes，按（+）号，然后从下拉菜单中选择目标。确保Container已设置为需要测试的应用。然后点击Close。 第2步：添加EarlGrey作为依赖框架 通过gem install earlgrey命令安装Earl gem。如果你还没有Ruby或者不是最新版本，请参阅Ruby 安装部分。 在Podfile的test target部分里，添加EarlGrey作为依赖项。 1234567target TEST_TARGET do project PROJECT_NAME use_frameworks! # Required for Swift Test Targets only inherit! :search_paths # Required for not double-linking libraries in the app and test targets. pod &apos;EarlGrey&apos;end 完成后，请执行pod install。 有关不同版本之间的兼容性，请参阅此文档。 要下载特定版本的gem，请使用gem install earlgrey -v x.y.z. 第3步：打开workspace并验证你是否看到EarlGrey。成功运行pod install命令后，打开生成的workspace并在Pods /目录中找到安装的EarlGrey。 生成的Pods /project应该类似于： 配置并运行你的第一次测试因为EarlGrey基于XCTest，所以在Xcode中创建你的第一个测试用例就像创建一个新的Unit Test类一样简单。 小心不要将Unit Test类与UI Test类混为一谈。 UI Test类使用添加到XCTest中的新UI Testing特性，但尚未与EarlGrey兼容。 Ctrl +单击你的应用程序源文件的文件夹，然后选择New file….将出现以下对话框： 选择Unit Test类，然后单击Next。 在以下屏幕上，输入测试用例的名称。 对于这个例子，让我们把它称作MyFirstEarlGreyTest： 在下一个屏幕上，确保测试用例与Unit Test target相关联。 在这种情况下，我们的target是SimpleAppTests： Xcode将为我们创建一个新的测试用例，但我们不需要其中的大部分代码。 让我们更改代码，只留下一个测试方法，并包含EarlGrey框架，如下所示： 对于Swift测试： 12345678import EarlGreyclass MyFirstEarlGreyTest: XCTestCase &#123; func testExample() &#123; // Your test actions and assertions will go here. &#125;&#125; 对于Objective-C测试： 123456789101112@import EarlGrey;@interface MyFirstEarlGreyTest : XCTestCase@end@implementation MyFirstEarlGreyTest- (void)testExample &#123; // Your test actions and assertions will go here.&#125;@end 现在让我们添加一个简单的EarlGrey断言，检查是否存在window并证明它是显示的。 以下是最终的测试结果： 对于Swift测试： 1234func testExample() &#123; EarlGrey.selectElement(with: grey_keyWindow()) .assert(grey_sufficientlyVisible())&#125; 对于Objective-C测试： 1234- (void)testPresenceOfKeyWindow &#123; [[EarlGrey selectElementWithMatcher:grey_keyWindow()] assertWithMatcher:grey_sufficientlyVisible()];&#125; 就是这样！ 与其他任何单元测试一样，此测试将显示在测试导航器中，因此你只需单击运行图标或按Ctrl +单击测试名称，然后选择测试“testPresenceOfKeyWindow”即可运行该测试。 由于这是一个常规的单元测试，因此你可以在测试和应用程序代码中放置断点，也可以照常使用内置工具。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EarlGrey-README的翻译]]></title>
    <url>%2F2018%2F05%2F14%2FEarlGrey-README%E7%9A%84%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[EarlGreyEarlGrey是一个基于原生的iOS UI自动化测试框架，它使你能够编写清晰、简洁的测试用例。 借助EarlGrey框架，可以访问增强的同步功能。 EarlGrey自动与UI，网络请求和各种队列同步，但仍然允许你根据需要手动实施自定义时间。 EarlGrey的同步功能有助于确保UI在执行操作之前处于稳定状态。这极大地提高了测试稳定性并使测试具有高度可重复性 EarlGrey与XCTest框架协同工作，并与Xcode的Test Navigator集成，因此你可以直接从Xcode或命令行（使用xcodebuild）运行测试。 开始用户的说明书位于EarlGrey/docs文件夹中。要开始，请查看EarlGrey功能，检查兼容性，然后安装/运行EarlGrey与测试目标。在完成所有配置后，请查看EarlGrey API并开始编写自己的测试。 帮助如果你需要帮助，可以使用多种渠道。首先检查FAQ。如果你在阅读FAQ后遇到更多问题，请参阅Known Issues。你可以在位于stackoverflow.com的#earlgrey标签询问更多具体问题。你也可以在我们的Google小组与我们开始新的讨论，或请求加入我们的协作频道。 分析为了提升和改进EarlGrey，该框架收集使用数据并将其上传到Google Analytics。更具体地说，该框架收集MD5加密后的Bundle ID，测试类名称和测试方法名称。这些信息使我们能够测量使用量。有关分析集合的更多详细信息，请仔细阅读包含实现细节的GREYAnalytics.m文件。如果他们愿意，用户可以通过在他们的测试中禁用Analytics配置设置来选择退出 - （void）setUp方法： In Objective-C: 12// Disable analytics.[[GREYConfiguration sharedInstance] setValue:@(NO) forConfigKey:kGREYConfigKeyAnalyticsEnabled]; In Swift: 12// Disable analytics.GREYConfiguration.sharedInstance().setValue(false, forConfigKey: kGREYConfigKeyAnalyticsEnabled) 贡献代码 在做出贡献之前，请确保你遵循了CONTRIBUTING.md中的指导原则。 建立一个EarlGrey项目 从GitHub Clone EarlGrey。 1git clone https://github.com/google/EarlGrey.git 在Clone EarlGrey后，使用setup-earlgrey.sh下载所有依赖项。 脚本运行完成后，打开EarlGrey.xcodeproj并确认所有target成功构建。 你现在可以使用EarlGrey.xcodeproj对框架进行更改。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS Cocoapods私有库的创建]]></title>
    <url>%2F2018%2F04%2F12%2FiOS-Cocoapods%E7%A7%81%E6%9C%89%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[私有库的原理上回书说道，我们的公有库的索引文件是通过 1pod setup 命令缓存到本地的，我们按照索引文件里面的信息查找、使用我们的第三方库。所以，我们要仿照这个这个模式，建立一个远端的私有的Specs仓库，并将私有库的描述文件上传到这个仓库里，从而达到我们使用私有库的目的。 准备工作同上回书，iOS Cocoapods公有库的创建（当然，Specs仓库和代码仓库是私有的） 正文Specs仓库首先，我们要建立一个仓库， 1pod repo add &apos;你的私有Specs仓库名&apos; &apos;你的私有Specs仓库地址&apos; 之后，我们在Finder中搜索 1~/.cocoapods/repos 或者使用 1pod repo list 命令来检查是否创建成功。 pod spec文件虽然这个地方上回书已经说过了，但是这步真的好重要啊，好想强调给你们，一定要照着上次说的模板好好写啊，要不要只会男上加男啊（我必须皮这一下）。写好了也验证通过了（不通过的话一定要好好检查spec文件），打上标签push到远程仓库。最后将我们的描述信息，push到我们的Specs仓库里。 1pod repo push &apos;你刚才的私有Specs仓库名&apos; &apos;你的描述文件.podspec&apos; 成功的话就会在 1~/.cocoapods/repos/你的私有Specs仓库名 中发现新增的仓库描述信息啦 使用在Podfile中添加Specs仓库地址 1234567source &apos;http://git.demo.com/ios/DemoSpecs.ios.git&apos; #私有仓库地址（源文件）source &apos;https://github.com/CocoaPods/Specs.git&apos; #官方仓库地址platform:ios, &apos;8.0&apos;target &apos;demo&apos; do #工程名称 pod &apos;AFNetworking&apos; pod &apos;你的私有库名&apos;end 最后再install一下就可以啦，有其他的问题或者的话欢迎在下面留言与我交流哦。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS Cocoapods公有库的创建]]></title>
    <url>%2F2018%2F04%2F07%2FiOS-Cocoapods%E5%85%AC%E6%9C%89%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[公有库的原理我们为准备制作的公有库生成一个描述文件spec（里面包含了框架的名称、代码的存放地址、版本号等）,提交到Cocoapods的远程索引库中，再将我们的源码push到远程仓库中，在我们或者他人，执行 1pod setup 命令时，索引文件就被缓存到我们的本地了，在我们使用 1pod search 命令时，本地的索引库就会检索出符合条件的库的描述文件spec 1234567891011121314-&gt; SDWebImage (4.0.0) Asynchronous image downloader with cache support with an UIImageView category. pod &apos;SDWebImage&apos;, &apos;~&gt; 4.0.0&apos; - Homepage: https://github.com/rs/SDWebImage - Source: https://github.com/rs/SDWebImage.git - Versions: 4.0.0, 4.0.0-beta2, 4.0.0-beta, 3.8.2, 3.8.1, 3.8.0, 3.7.6, 3.7.5, 3.7.4, 3.7.3, 3.7.2, 3.7.1, 3.7.0, 3.6, 3.5.4, 3.5.2, 3.5.1, 3.5, 3.4, 3.3, 3.2, 3.1, 3.0, 2.7.4, 2.7, 2.6, 2.5, 2.4 [master repo] - Subspecs: - SDWebImage/Core (4.0.0) - SDWebImage/MapKit (4.0.0) - SDWebImage/GIF (4.0.0) - SDWebImage/WebP (4.0.0) ，从而按照描述文件上面的信息实现安装。 准备工作 安装cocoapods 命令行工具 代码托管仓库（GitHub Coding.net等） 准备上传的代码 正文想要创建开源的Pod库，需要注册一个Cocoapods账号，这个操作过程在终端进行，email使用你的GitHub邮箱，如果你在多终端操作时，这也是你的登录命令 1$ pod trunk register GitHub_email &apos;user_name&apos; --verbose 在终端出现如下文字时， 1[!] Please verify the session by clicking the link in the verification email 登录你的邮箱进行验证。成功后，在终端输入 1pod trunk me 就可以看到你的注册信息啦 123456789datianyedeiMac:demo dream$ pod trunk me - Name: ryanflecher - Email: owenlizhongzhen@163.com - Since: April 1st, 19:40 - Pods: - YGTools - Sessions: - April 1st, 19:40 - August 10th, 00:15. IP: 183.129.240.106 - April 6th, 23:03 - August 13th, 00:25. IP: 115.196.216.10 关于git仓库关于新建项目仓库这里就不多说了，里面至少要包含你的代码文件、开源许可证（LICENSE）、仓库说明（README.md），还有之后要创建的描述文件，ignore文件也顺便检查一下，有没有忽略你要提交的代码的所属语言，不然后面一定会报错。 编辑描述文件cd到仓库目录下，在终端输入 1pod spec create 你的项目名称 这样就会在仓库中生成 你的项目名称.podspec文件 文件中的相关配置建议搜索一下相关模板，因为很多配置不是必须的，写的越多，错的越多(╯‵□′)╯︵┻━┻，这里就不贴出了。 写好之后，要使用 1pod lib lint 命令验证你编辑的描述文件是否正确，当然了，warning和error是常伴我们左右的，比如描述比简介短啦这种的，你可以在后面忽略掉warning 1pod lib lint --allow-warnings 这里我想着重强调一下“s.version = ”不要乱填 因为之后要与你push代码的标签一致 验证成功之后，打上和之前“s.version = ”一样的版本号标签，把代码提交到托管仓库。 发布来到最后，我们将发布我们的描述仓库 1pod trunk push 你的项目名.podspec 这一步包括了验证.podspec格式、将.podspec转为JSON、对master进行提交及合并操作。 成功后的样子 12345678910111213Updating spec repo `master`Validating podspec -&gt; YGTools (1.0.0)Updating spec repo `master`-------------------------------------------------------------------------------- 🎉 Congrats 🚀 BYPhoneNumTF (1.0.0) successfully published 📅 March 7th, 01:39 🌎 https://cocoapods.org/pods/YGTools 👍 Tell your friends! 使用是不是迫不及待想使用了呢，别急，就像我们之前说的，本地索引库还没有更新，所以我们要使用 1pod setup 更新一下，如果不出意外的话，你就会查询到你的项目啦。 其他有的小伙伴使用的demo文件操作的，如果之后想删除掉怎么办呢，我们可以使用 1$ pod trunk delete NAME VERSION 命令来删除，更多的命令等你去发现哦。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“关于互联网金融合规备案相关政策的时间线（不定期更新）”]]></title>
    <url>%2F2018%2F03%2F26%2F%E2%80%9C%E5%85%B3%E4%BA%8E%E4%BA%92%E8%81%94%E7%BD%91%E9%87%91%E8%9E%8D%E5%90%88%E8%A7%84%E5%A4%87%E6%A1%88%E7%9B%B8%E5%85%B3%E6%94%BF%E7%AD%96%E7%9A%84%E6%97%B6%E9%97%B4%E7%BA%BF%EF%BC%88%E4%B8%8D%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89%E2%80%9D%2F</url>
    <content type="text"><![CDATA[背景公司的APP最近迭代时被要求出示在中国银行业监督管理委员会（以下简称：银监会）备案的相关文件， Please submit the China Banking Regulatory Commission record-filing copy. If you have filed a record with the China Banking Regulatory Commission, please provide documentary evidence of the registration. 作为一名iOS开发，时常要和App Store的审核人员打交道，因为许多审核条款是以我国对于该行业的监管政策为基础的，所以审核人员经常在审核时要求提供相关材料，我们需要了解这些政策以避免在与审核人员沟通时产生误会。以下是本人根据时间先后整理的相关政策（链接），参考时请结合所在省市区金融办具体政策，欢迎补充指正。 2015-12-28 《网络借贷信息中介机构业务活动管理暂行办法（征求意见稿）》《网络借贷信息中介机构业务活动管理暂行办法（征求意见稿）》 《网络借贷信息中介机构业务活动管理暂行办法（征求意见稿）》主要内容说明 《网络借贷信息中介机构业务活动管理暂行办法（征求意见稿）》有关问题的解答 2016-08-24《网络借贷信息中介机构业务活动管理暂行办法》《网络借贷信息中介机构业务活动管理暂行办法》 2016-11-28《网络借贷信息中介机构备案登记管理指引》《网络借贷信息中介机构备案登记管理指引》 2017-02-22《网络借贷资金存管业务指引》《网络借贷资金存管业务指引》 2017-08-28《网络借贷信息中介机构业务活动信息披露指引》《网络借贷信息中介机构业务活动信息披露指引》 2017-12-13《关于做好P2P网络借贷风险专项整治整改验收工作的通知》 关于做好P2P网络借贷风险专项整治整改验收工作的通知 网贷整治办函(2017)57号 各省（区、市、计划单列市）网络借贷风险专项整治联合工作办公室： 为扎实推进P2P网络借贷（以下简称“网贷”）风险专项整治工作，在分类处置工作基础上，进一步加强各省（区、市、计划单列市）辖内网贷机构的整改验收工作，根据《网络借贷信息中介机构业务活动管理暂行办法》（2016年第1号主席令，以下简称《办法》）、《关于印发《P2P网络借贷风险专项整治工作实施方案&gt;的通知》(银监发(2016)11号）和相关工作部署精神，现将网贷风险专项整治整改验收工作有关要求及安排通知如下： 一、充分认识整改验收的重要意义 整改验收是本次网贷风险专项整治工作的关键核心环节，各省（区、市、计划单列市）网络借贷风险专项整治联合工作办公室（以下简称各地整治办）应当高度重视整改验收相关工作，加强统筹，强化责任，做好整改验收与机构备案的衔接，科学把握备案机构数量和质量，按照“明确标准、严格把关、积极稳妥”的原则，一家一策、整改验收合格一家、备案一家，有序开展辖内存量网贷机构的整改验收与备案登记工作，实现行业市场出清、扶优抑劣、规范纠偏，确保向常态化监管的稳步过渡，真正引导行业守住法律底线和政策红线，回归信息中介本质，坚持小额分散功能，定位线上经营模式，建立合理定价机制，以服务实体经济和小微企业。 二、扎实做好整改验收的各项工作 （一）成立验收专班，落实各方责任 各省（区、市、计划单列市）人民政府应当高度重视本次整改验收工作，提高认识，切实落实属地管理职责，做好组织管理和风险预案，成立由省（区、市、计划单列市）金融办、银监局以及人民银行分支机构、公安、通信管理、工商管理等部门组成的联合整改验收小组，进行交叉核验，统筹考虑并确定验收标准和措施。 各地整治办应当切实落实部门责任，加强对整改验收工作的组织协调，充分利用各职能部门及第三方专业机构的力量做好整改验收工作。 各地整治办应指定官方网站对拟备案网贷机构的整改验收情况进行公示，公示时间应不少于两周，并要求网贷机构在自身官方网站及APP上及时对本机构整改验收及备案登记情况进行信息披露。 整改验收公示期间，各地整治办如收到异地整治办、出借人或借款人以及其他网贷机构对公示机构的举报，经核查属实的，各地整治办应当撤销公示内容并对网贷机构重新进行整改验收。 最终的整改验收合格证明文件应当由本省（区、市、计划单列市）金融办、银监局的负责同志共同签发。 （二）严格验收标准，确保分类施策 各地整治办应当对辖内机构进行全覆盖、有重点的实质检查，可以通过核查账务系统、资金流水、融资项目真实性、抽查借贷合同、暗访检查违规线下营销和违规宣传行为、产品合规性调查等手段，查实查透网贷机构存在的问题，严防被检查机构“带病”通过验收。 对于不同情况的网贷机构，应当分类施策、科学处置： 一是对于验收合格的网贷机构，应当尽快予以备案登记，确保其正常经营； 二是对于积极配合整改验收工作但最终没有通过的机构，可以根据其具体情况，或引导其逐步清退业务、退出市场，或整合相关部门及资源，采取市场化方式，进行并购重组； 三是对于严重不配合整改验收工作，违法违规行为严重，甚至已经有经侦介入或已经失联的机构，应当由相失部门依据《非法金融机构和非法金融业务活动取缔办法》等相关法律法规予以取缔； 四是对于为逃避整改验收，暂停自身业务或不处于正常经营状态的机构，各地整治办要予以高度重视，要求此类机构恢复正常经营后，酌情予以备案； 五是对于行业中业务余额较大、影响较大、跨区域经营的机构，由机构注册地整治办建立联合核查机制，向机构业务发生地整治办征求相关意见。 各省（区、市、计划单列市）要结合本地区各部门、各机构的实际情况，积极稳妥推进相关工作，充分协调工商管理、公安等具有行政执法权的部门在机构退出环节依法履行相应职能，确保不发生处置风险的风险，守住不发生系统性区域性风险和不发生大规模群体事件的底线。 （三）明确时间节点，严格政策界限 各省（区、市、计划单列市）对于辖内机构的具体整改验收，应当明确不同的时间节点，分类加以规制，具体包括： 一是根据互联网金融风险专项整治领导小组有关要求，对于在《办法》发布之日（2016年8月24日）后新设立的网贷机构或新从事网络借贷业务的网贷机构，在本次网贷风险专项整治期间，原则上不予备案登记； 二是对于自始末纳入本次网贷专项整治的各类机构，在整改验收期间提出备案登记申请的，各地整治办不得对此类机构进行整改验收及备案登记； 三是对于《办法》规定的十三项禁止性行为及单一借款人借款上限规定，网贷机构应当自2016年8月24日后不再违反，相应存量业务没有化解完成的网贷机构不得进行备案登记； 四是对于开展过涉及房地产首付贷、校园贷以及现金贷等业务的网贷机构，应当按照《关于进一步加强校园贷规范管理工作的通知》（银监发[2017]26号）、《关于对“现金贷”业务进行规范整顿通知》（整治办函[2017]141号）的要求，暂停新增业务，对存量业务逐步压缩，制定退出时间表，对于相关监管要求下发后继续违规发放以上三类业务的机构不予备案； 五是辖内各网贷机构应当与通过网贷专项整治领导小组办公室组织开展的网贷资金存管业务测评的银行业金融机构开展资金存管业务合作； 六是对于在规定时间内没有通过本次整改验收，无法完成备案登记但依然实质从事网贷业务的机构，各省（区、市、计划单列市）应当协调相应职能部门予以处置，包括注销其电信经营许可、封禁网站，要求金融机构不得向其提供各类金融服务等。 （四）把握工作进度，逐步完成备案 请各省（区、市、计划单列市）处理好工作力度和节奏的关系，严格遵守最新的互联网金融风险专项整治大的时间框架，分阶段完成整改验收以及后续备案登记工作： 1、2018年4月底之前完成辖内主要网贷机构的备案登记工作； 2、对于违规存量业务较多，难以及时完成处置的部分网贷机构，应当于2018年5月底之前完成相应业务的处置、剥离以及备案登记工作； 3、对于难度极大、情况极其复杂的个别机构，最迟应当于2018年6月末之前完成相关工作。 附件：关于整改验收过程中部分具体问题的解释说明 P2P网络借贷风险专项整治工作领导小组办公室 （银监会普惠金融部代章） 附件： 关于整改验收过程中部分具体问题的解释说明 1．关于债权转让有关问题。 对于债权转让是否合规，应当具体问题具体分析。为解决流动性问题，在出借人之间进行的低频次债权转让，应认定为合规；对于开展类资产证券化业务或实现以打包资产、证券化资产、信托资产、基金份额等形式的债权转让行为则应该认定为违规；对于由网贷机构高管或关联人根据机构的授权，与借款人签订借款合同，直接放款给借款人，再根据借款金额在平台放标，将债权转让给实际出借人的“超级放款人”模式的债权转让，由于其可能导致网贷机构虚构标的、将项目拆分期限错配、直接或间接归集出借人资金等行为，应当认定为违规；以活期、定期理财产品的形式对接债权转让标的，由于可能造成资金和资产的期限错配，应当认定为违规。同时，各网贷机构不得以出借人所持债权作为抵（质）押，提供贷款。 2．关于风险备付金有关问题。 目前市场上部分机构出于解决信用风险的考虑，提取了部分风险备付金，这一经营模式与网贷机构的信息中介定位不符。应当禁止辖内机构继续提取、新增风险备付金，对于已经提取的风险备付金，应当逐步消化，压缩风险备付金规模。同时严格禁止网贷机构以风险备付金进行宣传。各地应当积极引导网贷机构采取引入第三方担保等他方式对出借人进行保障。 3．关于资金存管有关问题。 网贷专项整治领导小组办公室委托中国互联网金融协会开展网贷资金存管业务测评，测评工作将按照“标准统一、质量优先、客观公正、实事求是”的原则，严格依据《网络借贷资金存管指引》有序开展。网贷机构应当与通过测评的银行业金融机构开展资金存管业务合作。 4．关于综合借款成本及“现金贷”有关问题。 各地应当继续做好对“现金贷”的清理整顿工作，要求辖内网贷机构依照《关于对“现金贷”业务进行规范整顿通知》相关要求开展业务，对于继续撮合或变相撮合违反法律有关利率规定的借贷业务的网贷机构不予备案登记。 5．关于法人及分支机构备案有关问题。 申请备案登记的网贷机构应当为法人机构，在申请登记的同时，应当将本法人机构的所有分支机构信息报送至本地区网贷整治办公室，同时，相关整治办公室应当及时共享相关信息，并密切配合，共同处置相关风险。 6．关于线下经营的有关问题。 对于大规模从事线下营销的网贷机构，应当消减淘汰或转型线下营销门店及人员，清理、摘除相关标示、标脾、宣传牌、宣传单等，不得再在互联网、固定电话、移动电话等电子渠道以外的物理场所进行宣传或推介融资项目。 7．关于网贷机构业务规模控制有关问题。 网贷机构应当持续优化自身业务结构，调控自身业务规模，在前述要求的基础上，应当自整改通知书下发之日起，实现存量违规业务持续下降，确保不再新增任何违规业务。对于存在违反《办法》规定的十三项禁止性行为以及单一借款人上限的网贷机构，在其相应违规业务没有化解完成前，各省（区、市、计划单列市）整治办应当不予备案登记。 8．关于网贷机构与地方金融交易所合作有关问题。 对于与各类地方金融交易所进行合作的网贷机构，应当停止合作，存量合作业务逐步转让或清偿，最终于本次专项整治结束之前完成。 9．关于网贷机构业务外包及机构分立有关问题。 辖内网贷机构不得将核心业务进行外包。对于将自身业务分割，将原有网贷机构分立为不同实体的情况，如果其分立出的实体，只与将其分立出的网贷机构进行业务合作的，则应当将分立后的机构视为原网贷机构的组成部分，进行一并验收管理。 10．关于网贷机构信息披露有关问题。 网贷机构应该继续完善自身信息披露，于自身官方网站或APP上确实披露项目风险及资金投向，同时将本法人机构的所有分支机构信息报送至本地区网贷整治办公室，在本次专项整治结束前，网贷机构应当依据银监会发布的《网络借贷信息中介机构业务活动信息披露指引》进行完整的信息披露。 11．关于网贷机构基础设施有关问题。 对于缺乏合规的网络安全设施的网贷机构，应于本次专项整治结束前，提升安全防护和开发能力，确保系统能够满足保护客户资金信息安全、防止黑客攻击和系统中断等信息科技安全要求。]]></content>
      <categories>
        <category>审核相关</category>
      </categories>
      <tags>
        <tag>审核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次App Store开发者名称的修改]]></title>
    <url>%2F2018%2F03%2F19%2F%E8%AE%B0%E4%B8%80%E6%AC%A1App-Store%E5%BC%80%E5%8F%91%E8%80%85%E5%90%8D%E7%A7%B0%E7%9A%84%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[背景公司之前使用的开发者账号因为一些原因使用了“外包服务有限公司”作为后缀，给项目审核造成了很大的麻烦。我们都知道，从2017年末到2018年初，出于对现金贷和P2P理财平台的监管，苹果加强了对金融借贷类APP的审核，公司如果不具备相关资质，所开发的APP是不允许上架的，我们也不例外，在“正常”的拒绝理由之后，还有一句话饶有意味 We found that your app facilitates loan applications, but the seller and company names associated with your app do not reflect the financial institution in the app or its metadata, as required by Guideline 3.2.1(viii) of the App Store Review Guidelines. 什么意思呢，简单来说就是你的应用有助于贷款申请，但与你的应用关联的卖家和公司名称并未反映App中金融机构或其元数据，正如App Store评论指南的准则3.2.1（viii）所要求的。这是什么意思o(╯□╰)o，看脸就被拒绝了吗，显然是不能让他们得逞的(╯‵□′)╯︵┻━┻，那么我就开始我们的维权之路——修改公司名称。 step 1既然是修改公司名称，那么我们的第一站就是苹果开发者客服了，电话就不在这里贴出了，自己百度好了。这里请注意：如果你不是公司苹果开发者账号的持有人的话，一定要让账号的持有人（申请这个账号的人）在一旁和你一起接电话，这里尽可能不要皮（相信我，皮这一下你不会开心的），不要冒充账号持有人，不要冒充账号持有人，不要冒充账号持有人，因为苹果客服对用户的隐私保护很严格，只要有一个问题你答错了，这次通话就结束了，等到再次接通，又是15分钟的等待，所以不要因小失大。那么在这里获得的信息是，一般情况下来讲，公司的开发者名称是不可以随意更改的，但是如果你的公司在工商局的信息更改的话，是可以有特例的。客服也很客气的提供了修改名称的相关步骤， 联系邓白氏更新公司名 联系邮件为：appdeveloper@dnb.com 联系苹果更改开发者账号对应的公司名随后会给你一个案例编号，请牢记这个编号，如果你不想再花时间描述问题的话。 step2那么根据指引给邓白氏发邮件，这里没有什么太需要注意的点，在邮件发出后，要及时留意有没有邓白氏系统发过来的确认信息，然后根据对方要求填写相关资料。在资料更新成功之后，记得查询确认下邓白氏编码所对应的公司信息是否正确，以免之后再出现类似问题。 step3再次打通苹果客服的电话，提供了案例编号并告知邓白氏的操作已经成功，客服将申请单发到了邮箱中，这里有一点需要注意，即使对方确认收到了你的回复信息，也要注意跟进，因为有的时候对方并不是严格按照邮件上面的规定信息回复时间回复你的，你要自己多跟进。所以在两天没有回复之后，拨打了对方的电话，对方将电话转接给了苹果资深顾问，沟通之后，对方发来了更改邮件。在指定的链接发送对方要求的附件之后，需要回复邮件告知对方。等待一天之后，收到了对方的确认邮件那么我们这次的行动已经圆满成功了。]]></content>
      <categories>
        <category>审核相关</category>
      </categories>
      <tags>
        <tag>审核</tag>
      </tags>
  </entry>
</search>
